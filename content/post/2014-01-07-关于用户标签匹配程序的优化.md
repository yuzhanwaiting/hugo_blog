---
title: sphinx优化用户标签匹配
date: 2014-01-07
categories:
  - php
tags:
  - sphinx
  - 用户匹配
---
前段时间，正好忙于搜索的工作。数据库也不大，总共下来估计也才10w左右的数据。但考虑到之后的扩展，就选用了sphinx。对于sphinx的优点，相信用过的都知道，这里就不多费口舌。

后来，项目版本更新之后，原计划的搜索需要做一次整改。调整如下：

每个登录的用户，前台有个公共标签，这个作为搜索条件(sphinx解决，不多解释)。而且，每个用户还有个隐性标签，供后台使用。当用户搜索关键词的时候就需要按照关键词的匹配度来进行排序。

![示例图1][1]

如上图，用户自身有三个隐性标签，经过搜索之后，出现四条结果。按标签匹配度来算应该结果一在最前面，结果四在最后面。既然如此，我们该如何解决这个问题呢？

要解决这个问题，我们先得走个过程。

我们知道，匹配度的高低，得按照标签相同的对数来计算。而之前所做的隐性标签，只是简简单单的以id和人来挂钩。根据此类结构我们能够想到的方法，可以按照如下流程来走

```
$tag1 = "标签一";
$tag2 = "标签二";
$tag3 = "标签三";

//第一步，取出用户标签
$user_tags = array($tag1,$tag2,$tag3);

//第二步，取出搜索结果标签
$result_tags = array(
	"res1" =&gt; array($tag1,$tag2,$tag3),
	"res2" =&gt; array($tag1,$tag2),
	"res3" =&gt; array($tag2,$tag3),
	"res4" =&gt; array($tag3)
);

//第三步，用户标签做匹配
$result_weight = array();
foreach ($result_tags as $key =&gt; $val)
	$result_weight[$key] = count(array_intersect($user_tags,$val));

/*输出数组
print_r($result_weight);
Array
(
    [res1] =&gt; 3
    [res2] =&gt; 2
    [res3] =&gt; 2
    [res4] =&gt; 1
)
*/

//根据上述排序，我们就可以得到正确的顺序，加以转换，就可以正确输出
```

以上程序似乎解决了问题，但实际上并非如此。我们仔细观察会发现，数据量大了之后，原先存入mysql的tags，在读取上造成了很大的开销。针对这个，我们可以选择缓存，如redis或memcache都是不错的选择。

那么，是否可以说大功告成了？

我们的答案是没有，其实程序第三步做标签匹配的时候，存在大量的计算，再10w条数据下，程序要经过10w次计算，这对于性能的消耗，可想而知。因此，此方法是行不通的。

既然行不通，我们有没有其他方法？

经过思考，我们找到一个新的方法。把这个过程交给sphinx去做,下面就慢慢道来：

我们知道，`sphinx(coreseek)`,对于文字匹配，会计算权重。匹配的项越多，权重越高。因此，完全可以用来做权重。

慢着，等等，你不可能让sphinx搜索tags的id，这个重复的概率太大了，会导致搜索不准确。

所以，我们加上一个字段，给tag做了冗余，附加到用户表上，整个流程如下图

![流程图][2]

我们把匹配的工作交给sphinx，高效而且精准。将返回来的值进行排序，就可以得到正确结果。

当然，实际工作中，可能没有我说的那么简单，还有很多步奏要处理，不过，大概的思路就是如此。

希望此文对大家有帮助。

 [1]: /public/img/images/2014/01/QQ截图20140107134143.png
 [2]: /public/img/images/2014/01/QQ截图20140107143046.png